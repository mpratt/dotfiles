#!/bin/bash
#############################################################
# /etc/rc.d/rc.firewall
#
# start/stop/restart/save/restore Firewall
#
# Licencia: MIT
# Copyright (C) 2011 by Michael Pratt <pratt@hablarmierda.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
###########################################################
SYSCTL="/sbin/sysctl -w"
IPT="/usr/sbin/iptables"
IPTS="/usr/sbin/iptables-save"
IPTR="/usr/sbin/iptables-restore"

# Internet Interface
INET_IFACE=( eth0 wlan0 ppp0 )

# Localhost Interface
LO_IFACE="lo"
LO_IP="127.0.0.1"

#############################################################
# Save arguments handled here
#############################################################
firewall_save()
{
	echo -n "Saving firewall to /etc/sysconfig/iptables ... "
	${IPTS} > /etc/sysconfig/iptables
	echo "done"
}

#############################################################
# Restore arguments handled here
#############################################################
firewall_restore()
{
	echo -n "Restoring firewall from /etc/sysconfig/iptables ... "
	${IPTR} < /etc/sysconfig/iptables
	echo "done"
}

#############################################################
# Flush Iptables rules
#############################################################
firewall_flush()
{
	echo "Flushing Tables ..."
	# Reset Default Policies
	${IPT} -P INPUT ACCEPT
	${IPT} -P FORWARD ACCEPT
	${IPT} -P OUTPUT ACCEPT
	${IPT} -t nat -P PREROUTING ACCEPT
	${IPT} -t nat -P POSTROUTING ACCEPT
	${IPT} -t nat -P OUTPUT ACCEPT
	${IPT} -t mangle -P PREROUTING ACCEPT
	${IPT} -t mangle -P OUTPUT ACCEPT

	# Flush all rules
	${IPT} -F
	${IPT} -t nat -F
	${IPT} -t mangle -F

	# Erase all non-default chains
	${IPT} -X
	${IPT} -t nat -X
	${IPT} -t mangle -X
    ${IPT} --flush
}

#############################################################
# This is the firewall
#############################################################
firewall_start()
{
	local interface;
	echo "Create and populate custom rule chains ..."

	# Route the rest to the appropriate user chain
	for interface in ${INET_IFACE[@]}; do

		# Inbound Internet Packet Rules
		# Accept Established Connections
		${IPT} -A INPUT -p ALL -i ${interface} -m state --state ESTABLISHED,RELATED -j ACCEPT

		${IPT} -A INPUT -p TCP -i ${interface} -j tcp_inbound
		${IPT} -A INPUT -p UDP -i ${interface} -j udp_inbound
		${IPT} -A INPUT -p ICMP -i ${interface} -j icmp_packets

        # To internet
		${IPT} -A OUTPUT -p ALL -o ${interface} -j ACCEPT

	done

    echo "Allow internet sharing on ppp0"
    ${IPT} -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
}

#############################################################
# Firewall Rules
#############################################################
firewall_rules()
{
    # Useful settings
    ${SYSCTL} net.ipv4.tcp_syncookies="1"
    ${SYSCTL} net.ipv4.conf.all.rp_filter="1"
    ${SYSCTL} net.ipv4.icmp_echo_ignore_broadcasts="1"
    ${SYSCTL} net.ipv4.conf.all.accept_source_route="0"
    ${SYSCTL} net.ipv4.conf.all.secure_redirects="1"
    ${SYSCTL} net.ipv4.conf.all.log_martians="1"
    ${SYSCTL} net.ipv4.ip_forward="1"

    # Create a chain to filter INVALID packets
    ${IPT} -N bad_packets

    # Create another chain to filter bad tcp packets
    ${IPT} -N bad_tcp_packets

    # Create separate chains for icmp, tcp (incoming and outgoing),
    # and incoming udp packets.
    ${IPT} -N icmp_packets

    # Used for UDP packets inbound from the Internet
    ${IPT} -N udp_inbound

    # Used to block outbound UDP services from internal network
    # Default to allow all
    ${IPT} -N udp_outbound

    # Used to allow inbound services if desired
    # Default fail except for established sessions
    ${IPT} -N tcp_inbound

    # Used to block outbound services from internal network
    # Default to allow all
    ${IPT} -N tcp_outbound

    # Set Policies
    ${IPT} -P INPUT DROP
    ${IPT} -P OUTPUT DROP
    ${IPT} -P FORWARD DROP

    echo "Create and populate custom rule chains ..."

    # Create a chain to filter INVALID packets
    ${IPT} -N bad_packets

    # Create another chain to filter bad tcp packets
    ${IPT} -N bad_tcp_packets

    # Create separate chains for icmp, tcp (incoming and outgoing),
    # and incoming udp packets.
    ${IPT} -N icmp_packets

    # Used for UDP packets inbound from the Internet
    ${IPT} -N udp_inbound

    # Used to block outbound UDP services from internal network
    # Default to allow all
    ${IPT} -N udp_outbound

    # Used to allow inbound services if desired
    # Default fail except for established sessions
    ${IPT} -N tcp_inbound

    # Used to block outbound services from internal network
    # Default to allow all
    ${IPT} -N tcp_outbound

    # Populate User Chains (Bad Packets)
    # Drop INVALID packets immediately
    ${IPT} -A bad_packets -p ALL -m state --state INVALID -j LOG \
        --log-prefix "Invalid packet: "

    ${IPT} -A bad_packets -p ALL -m state --state INVALID -j DROP

    # Then check the tcp packets for additional problems
    ${IPT} -A bad_packets -p tcp -j bad_tcp_packets

    # All good, so return
    ${IPT} -A bad_packets -p ALL -j RETURN

    # bad_tcp_packets chain
    ${IPT} -A bad_tcp_packets -p tcp ! --syn -m state --state NEW -j LOG \
        --log-prefix "New not syn: "
    ${IPT} -A bad_tcp_packets -p tcp ! --syn -m state --state NEW -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL NONE -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL NONE -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL ALL -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL ALL -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL FIN,URG,PSH -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags SYN,RST SYN,RST -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags SYN,RST SYN,RST -j DROP

    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags SYN,FIN SYN,FIN -j LOG \
        --log-prefix "Stealth scan: "
    ${IPT} -A bad_tcp_packets -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

    # All good, so return
    ${IPT} -A bad_tcp_packets -p tcp -j RETURN

    # icmp_packets chain
    #
    # This chain is for inbound (from the Internet) icmp packets only.
    # Type 8 (Echo Request) is not accepted by default
    # Enable it if you want remote hosts to be able to reach you.
    # 11 (Time Exceeded) is the only one accepted
    # that would not already be covered by the established
    # connection rule.  Applied to INPUT on the external interface.
    #
    # See: http://www.ee.siue.edu/~rwalden/networking/icmp.html
    # for more info on ICMP types.
    #
    # Note that the stateful settings allow replies to ICMP packets.
    # These rules allow new packets of the specified types.

    # ICMP packets should fit in a Layer 2 frame, thus they should
    # never be fragmented.  Fragmented ICMP packets are a typical sign
    # of a denial of service attack.
    ${IPT} -A icmp_packets --fragment -p ICMP -j LOG \
        --log-prefix "ICMP Fragment: "
    ${IPT} -A icmp_packets --fragment -p ICMP -j DROP

    # Echo - uncomment to allow your system to be pinged.
    # Uncomment the LOG command if you also want to log PING attempts
    #
    # ${IPT} -A icmp_packets -p ICMP -s 0/0 --icmp-type 8 -j LOG \
        #    --log-prefix "Ping detected: "
    # ${IPT} -A icmp_packets -p ICMP -s 0/0 --icmp-type 8 -j ACCEPT

    # By default, however, drop pings without logging. Blaster
    # and other worms have infected systems blasting pings.
    # Comment the line below if you want pings logged, but it
    # will likely fill your logs.
    ${IPT} -A icmp_packets -p ICMP -s 0/0 --icmp-type 8 -j DROP

    # Time Exceeded
    ${IPT} -A icmp_packets -p ICMP -s 0/0 --icmp-type 11 -j ACCEPT

    # Not matched, so return so it will be logged
    ${IPT} -A icmp_packets -p ICMP -j RETURN

    # Drop netbios calls
    # Please note that these rules do not really change the way the firewall
    # treats netbios connections.  Connections from the localhost and
    # internal interface (if one exists) are accepted by default.
    # Responses from the Internet to requests initiated by or through
    # the firewall are also accepted by default.  To get here, the
    # packets would have to be part of a new request received by the
    # Internet interface.  You would have to manually add rules to
    # accept these.  I added these rules because some network connections,
    # such as those via cable modems, tend to be filled with noise from
    # unprotected Windows machines.  These rules drop those packets
    # quickly and without logging them.  This prevents them from traversing
    # the whole chain and keeps the log from getting cluttered with
    # chatter from Windows systems.
    ${IPT} -A udp_inbound -p UDP -s 0/0 --destination-port 137 -j DROP
    ${IPT} -A udp_inbound -p UDP -s 0/0 --destination-port 138 -j DROP

    # Ident requests (Port 113) must have a REJECT rule rather than the
    # default DROP rule.  This is the minimum requirement to avoid
    # long delays while connecting.  Also see the tcp_inbound rule.
    ${IPT} -A udp_inbound -p UDP -s 0/0 --destination-port 113 -j REJECT

    # A more sophisticated configuration could accept the ident requests.
    # ${IPT} -A udp_inbound -p UDP -s 0/0 --destination-port 113 -j ACCEPT

    # Dynamic Address
    # If DHCP, the initial request is a broadcast. The response
    # doesn't exactly match the outbound packet.  This explicitly
    # allow the DHCP ports to alleviate this problem.
    # If you receive your dynamic address by a different means, you
    # can probably comment this line.
    ${IPT} -A udp_inbound -p UDP -s 0/0 --source-port 67 --destination-port 68 \
        -j ACCEPT


    # Not matched, so return for logging
    ${IPT} -A udp_inbound -p UDP -j RETURN

    # udp_outbound chain
    #
    # This chain is used with a private network to prevent forwarding for
    # UDP requests on specific protocols.  Applied to the FORWARD rule from
    # the internal network.  Ends with an ACCEPT


    # No match, so ACCEPT
    ${IPT} -A udp_outbound -p UDP -s 0/0 -j ACCEPT

    # tcp_inbound chain
    #
    # This chain is used to allow inbound connections to the
    # system/gateway.  Use with care.  It defaults to none.
    # It's applied on INPUT from the external or Internet interface.

    # Ident requests (Port 113) must have a REJECT rule rather than the
    # default DROP rule.  This is the minimum requirement to avoid
    # long delays while connecting.  Also see the tcp_inbound rule.
    ${IPT} -A tcp_inbound -p TCP -s 0/0 --destination-port 113 -j REJECT

    # A more sophisticated configuration could accept the ident requests.
    # ${IPT} -A tcp_inbound -p TCP -s 0/0 --destination-port 113 -j ACCEPT

    # sshd
    ${IPT} -A tcp_inbound -p TCP -s 0/0 --destination-port 22 -j ACCEPT


    # Not matched, so return so it will be logged
    ${IPT} -A tcp_inbound -p TCP -j RETURN

    # tcp_outbound chain
    #
    # This chain is used with a private network to prevent forwarding for
    # requests on specific protocols.  Applied to the FORWARD rule from
    # the internal network.  Ends with an ACCEPT


    # No match, so ACCEPT
    ${IPT} -A tcp_outbound -p TCP -s 0/0 -j ACCEPT

    # INPUT Chain
    echo "Process INPUT chain ..."

    # Allow all on localhost interface
    ${IPT} -A INPUT -p ALL -i ${LO_IFACE} -j ACCEPT

    # Drop bad packets
    ${IPT} -A INPUT -p ALL -j bad_packets

    # DOCSIS compliant cable modems
    # Some DOCSIS compliant cable modems send IGMP multicasts to find
    # connected PCs.  The multicast packets have the destination address
    # 224.0.0.1.  You can accept them.  If you choose to do so,
    # Uncomment the rule to ACCEPT them and comment the rule to DROP
    # them  The firewall will drop them here by default to avoid
    # cluttering the log.  The firewall will drop all multicasts
    # to the entire subnet (224.0.0.1) by default.  To only affect
    # IGMP multicasts, change '-p ALL' to '-p 2'.  Of course,
    # if they aren't accepted elsewhere, it will only ensure that
    # multicasts on other protocols are logged.
    # Drop them without logging.
    ${IPT} -A INPUT -p ALL -d 224.0.0.1 -j DROP
    # The rule to accept the packets.
    # ${IPT} -A INPUT -p ALL -d 224.0.0.1 -j ACCEPT

    # Drop without logging broadcasts that get this far.
    # Cuts down on log clutter.
    # Comment this line if testing new rules that impact
    # broadcast protocols.
    ${IPT} -A INPUT -m pkttype --pkt-type broadcast -j DROP

    # Log packets that still don't match
    ${IPT} -A INPUT -m limit --limit 3/minute --limit-burst 3 -j LOG \
        --log-prefix "INPUT packet died: "

    # However, invalid icmp packets need to be dropped
    # to prevent a possible exploit.
    ${IPT} -A OUTPUT -m state -p icmp --state INVALID -j DROP

    # Localhost
    ${IPT} -A OUTPUT -p ALL -s ${LO_IP} -j ACCEPT
    ${IPT} -A OUTPUT -p ALL -o ${LO_IFACE} -j ACCEPT

    # Log packets that still don't match
    ${IPT} -A OUTPUT -m limit --limit 3/minute --limit-burst 3 -j LOG \
        --log-prefix "OUTPUT packet died: "

}
#############################################################
# Spin this shit!
#############################################################
echo "Loading kernel modules ..."
#/sbin/depmod -a

# core netfilter module
/sbin/modprobe ip_tables

# the stateful connection tracking module
/sbin/modprobe ip_conntrack

# The ftp nat module is required for non-PASV ftp support
/sbin/modprobe ip_nat_ftp

# the module for full ftp connection tracking
/sbin/modprobe ip_conntrack_ftp

# the module for full irc connection tracking
/sbin/modprobe ip_conntrack_irc

# Choose action
case "${1}" in
	start|restart)
		firewall_flush
        firewall_rules
		firewall_start ;;

	stop)
		firewall_flush
		echo "Firewall completely flushed!  Now running with no firewall." ;;

	restore) firewall_restore ;;

	save) firewall_save ;;

	*) echo "$0 [start|stop|restart|restore|save]" ;;
esac
exit 0
